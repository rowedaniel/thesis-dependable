% A template for an Honours Thesis in English Language, NUS: adapted from one by Derek Lim (2016), itself adapted from a template for Carleton College comps papers by Andrew Gainer-Dewar (2013).
% This work is licensed under the Creative Commons Attribution 4.0 International License.
% To view a copy of this licence, visit http://creativecommons.org/licenses/by/4.0/ or send a letter to Creative Commons, 444 Castro Street, Suite 900, Mountain View, California, 94041, USA.
\documentclass[twoside]{memoir}
\usepackage{nus-el-ht}

% The Latin Modern font is a modernised replacement for the classic Computer Modern. Feel free to replace this with a different font package.
\usepackage{lmodern}
% Hyperref enables click-through hyperlinks in your PDF. The hyphens option indicates where to break long URLs.
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
% We use setspace to implement double-spacing, but with a specific command to leave quotes single-spaced.
\DisemulatePackage{setspace}\usepackage{setspace}
\expandafter\def\expandafter\quote\expandafter{\quote\singlespacing}
	\doublespacing

% tikz stuff
\usepackage[usenames,dvipsnames]{color}
\usepackage[table]{xcolor}
\usepackage{themecolors}
\usepackage{tikz}
\usetikzlibrary{positioning, shapes.multipart, arrows, arrows.meta, shadows, backgrounds, fit}

% code blocks
\usepackage{listings}
\lstdefinelanguage{isabelle}{%
    keywords=[1]{type_synonym,datatype,fun,abbreviation,definition,proof,have, using, thus, lemma,theorem,session,sessions,theories,text,section,inductive},
    keywordstyle=[1]\bfseries\color{isabelleouterblue},
    keywords=[2]{where,assumes,shows,and},
    keywordstyle=[2]\bfseries\color{isabelleoutergreen},
    keywords=[3]{if,then,else,case,of,SOME,let,in,O},
    keywordstyle=[3]\color{isabelleinnerblue},
    keywords=[4]{apply, by, done},
    keywordstyle=[4]\color{isabelleoutersalmon},
    morestring=[b]",
    morecomment=[n]{(*}{*)},
    % morecomment=[n]{\guilsingleft}{\guilsingright},
    stringstyle=\color{isabellequote},
    showstringspaces=false,
}
\lstdefinelanguage{file}{
}
\lstdefinestyle{tree}{
literate=
    {├}{{\smash{\raisebox{-1ex}{\rule{1pt}{\baselineskip}}}\raisebox{0.5ex}{\rule{1ex}{1pt}}}}1
    {└}{{\smash{\raisebox{0.5ex}{\rule{1pt}{\dimexpr\baselineskip-1.5ex}}}\raisebox{0.5ex}{\rule{1ex}{1pt}}}}1
    {─}{{\raisebox{0.5ex}{\rule{1.5ex}{1pt}}}}1
    {│}{{\smash{\raisebox{-1ex}{\rule{1pt}{\baselineskip}}}\raisebox{0.5ex}{\rule{1ex}{0pt}}}}1
}
\lstset{%
  language=isabelle,
  escapeinside={&}{&},
  columns=fixed,
  extendedchars,
  basewidth={0.5em,0.45em},
  basicstyle=\ttfamily,
  mathescape,
  frame=single,  % adds a frame around the code
}
\lstnewenvironment{nlisting}{\lstset{numbers=left}}{}


% For typesetting and labelling examples, incl. glossed examples.
% \usepackage{expex}
% 	\lingset{Everyex=\singlespace}

% Titling commands.
\title{Stacking Correspondence: Towards Formal Verification of a Network Stack}
\author{Daniel Neshyba-Rowe}
\supervisor {Alain K{\"a}gi}
\degree{Bachelor of Arts with Honors}
\faculty{Mathematical Sciences faculty}
\dept{Computer Science}
\date{Spring 2025}

\begin{document}
% First, we go into "front matter" mode.
% Among other things, this gives us Roman page numbers.
\frontmatter

% We tell LaTeX to make a title page, sections for acknowledgements, the abstract, and the table of contents (important!).

\maketitle

% \chapter{Acknowledgement}
% `This page is for making acknowledgements that have a direct bearing on the HT and is not for indulging in routine gestures of politeness or sentimental attitudinising. In all things, the candidate should be guided by good taste and good sense' \pgcitep{data-refinement}{2}. % Note also the command for citing a source and a page number.

\begin{abstract}
  % citations look like \citep{ell-ht-format}.
      %   Prior work led to the first proven-reliable and viable microkernel, seL4.
      % We hypothesize that similar reliability is possible for a performant IoT device.
      % As a proof of concept, we are creating a networked fish tank thermometer
      % with a complete IPv6 network stack and formally verifying all components.
      %
      % \begin{itemize}
      %     \item should be written for a more general audience
      %     \item alternatively: provide an additional plain-language summary
      % \end{itemize}
      % The job of a microkernel (or operating system) is to share resources
      % between different processes, including CPU time.
      % For a long time, it was thought that the operation of a microkernel was too complex for
      % any kind of formal verification in practice (concurrency makes this particularly tricky).
      % However, the seL4 foundation proved this wrong by creating and verifying the seL4 microkernel, and in doing so opened the gate for future research.
      % In our ongoing project, we hypothesize that the work of seL4 can be extended
      % to a fully-functional, verified embedded system, and attempt to build and
      % verify such a system.
      % For this thesis, we narrow the scope to just consider a piece of the networking stack (the UDP layer), and working on the verification for that piece.
      % In order to do this, we must formally define how we expect the UDP layer to work,
      % defining which behaviors are acceptable and which are not.
      % Subsequently, we must show that our implementation in fact conforms to these expectations.

      In 2009, seL4 was released as the first
      industry-grade microkernel which was formally verified to be correct.
      In our work, we hypothesize that it is possible
      to leverage seL4 to create a fully-functional embedded system running
      Internet Protocol version 6 (IPv6)
      that is verified at all software levels---something thought to be
      impossible in practice prior to the release of seL4.
      In our previous work, we designed and built the C code for a networked
      fish tank thermometer as a proof-of-concept of nontrivial complexity.
      Much of the complexity lies in the network stack, which consists of a number of components.
      Here, we focus a specific component of the network stack called the User Datagram Protocol (UDP) layer.
      Inspired by the seL4 verification effort,
      we define formal specifications, and refinement steps that show relationships between these specifications.
      More specifically, we define how we expect the UDP layer to
      work in an abstract specification, describing
      what behaviors are acceptable and which are not.
      Subsequently, we show that the design specification
      of our implementation conforms to these expectations.


\end{abstract}

\tableofcontents

% Include the list of figures and list of tables only if you actually have figures and tables! (The * after each indicates that it should not be included in the table of contents.)
%\listoffigures*
%\listoftables*

% Next, we go into "main matter" mode.
% This resets the page numbers and uses Arabic numerals.
\mainmatter

\chapter{Introduction}

\section{Background and motivation}

Modern life is full of computer systems.
Many such systems' failure would have catastrophic consequences---for instance,
failures in onboard software in cars, satellites, and medical equipment
could result in death or injury.
In these cases, the critical question is ``how do we know the software
will always behave as expected, without failure?''

Famously, it is exceedingly difficult to remove all bugs
from any piece of software.
In the linux kernel, for instance, bugs
introduced early in the development process
have evaded detection until recently
(\cite{Amlogic2016S905}).
Likewise, we cannot assume that as a software's lifecycle continues,
progressive bug patches will cause it to converge to a correct form.
A study of linux filesystems found no real decrease
in the number of bugs over time (\cite{lu2013study})---for every bug fixed,
as many new bugs were introduced.
Furthermore, testing is also not sufficient to eradicate all bugs.
As Dijkstra said, ``Testing shows the presence, not the absence of bugs''
(\cite{dijkstra-quote}).
A more effective solution is formal verification.

The goal of formal verification is to use rigorous mathematical statements
to prove that a piece of software works correctly, without bugs.
For our purposes, we will further require that these statements be
done in a proof engine, which is a computational tool for
automatically checking proofs.
This greatly reduces the chance of human error,
and provides the added benefit that small changes in the statements made
may be accommodated for by the proof engine.
Software frequently is updated or changed, so the ability for proofs
to be adaptable to changes in software is very useful.
The proof engine used in this thesis is Isabelle (\cite{wenzel2008isabelle}).

Prior to 2009, it was infeasible to prove functional correctness of
low-level systems.
This is due largely to the fact that low-level systems
encompass both hardware, and the microkernel or operating system,
requiring verification at several levels.
In fact, prior 2009, there did not exist a verified microkernel
that was suitable for real-world use.
Hence, even if a low-level application was correct,
there were likely bugs in the microkernel that prevented the low-level system
as a whole from functioning correctly.

In 2009 the seL4 microkernel was released as the first real-world usable
microkernel to be formally verified (\cite{Klein2014Verification}).
This allowed for a new field of ``ground-up'' verification,
where low-level systems could be verified all the way down to the hardware level.

This project sits within the context of seL4, and
continues work by \cite{Wilde2024Network}.
The end goals of this project are 1) to produce a fully functional
networked temperature sensor which records data from a fish tank
and sends that data over the network where it will be recorded externally, and 2)
to formally show that all software in the
thermometer works correctly, without any bugs or flaws that could cause
it to break or report incorrect data (barring physical malfunctions of the hardware).

\section{Network stack}
\begin{figure}[h]
    \centering
    \begin{tikzpicture}[node distance=4cm]
        % styles
        \tikzstyle{cell} = [rectangle, minimum width=4.6cm, minimum height=1cm, text centered, draw=black]
        \tikzstyle{arrow} = [line width=2pt,->,>=latex,draw=gray]
        \tikzstyle{box} = [draw, rectangle, align=center, minimum width=11cm, inner sep=3ex]

        % wrap
        \node (app_wrap) [cell, fill=application!80] {Application on Computer A};
        \node (udp_wrap) [cell, fill=udp!80, below=30pt of app_wrap] {UDP wrap};
        \node (ip_wrap) [cell, fill=ip!80, below=30pt of udp_wrap] {IP wrap};
        \node (ethernet_wrap) [cell, fill=ethernet!80, below=30pt of ip_wrap] {Ethernet wrap};
        \node (hardware_wrap) [cell, fill=hardware!80, below=30pt of ethernet_wrap] {Hardware};

        % unwrap
        \node (app_unwrap) [cell, fill=application!80, right=14pt of app_wrap] {Application on Computer B};
        \node (udp_unwrap) [cell, fill=udp!80, below=30pt of app_unwrap] {UDP unwrap};
        \node (ip_unwrap) [cell, fill=ip!80, below=30pt of udp_unwrap] {IP unwrap};
        \node (ethernet_unwrap) [cell, fill=ethernet!80, below=30pt of ip_unwrap] {Ethernet unwrap};
        \node (hardware_unwrap) [cell, fill=hardware!80, below=30pt of ethernet_unwrap] {Hardware};

        % layers
        \node[box, label={left:\rotatebox{90}{Higher-level}}, fit = (app_wrap) (app_unwrap)] (1) {};
        \node[box, label={left:\rotatebox{90}{Transport}}, fit = (udp_wrap) (udp_unwrap)] (1) {};
        \node[box, label={left:\rotatebox{90}{Network}}, fit = (ip_wrap) (ip_unwrap)] (1) {};
        \node[box, label={left:\rotatebox{90}{Data Link}}, fit = (ethernet_wrap) (ethernet_unwrap)] (1) {};
        \node[box, label={left:\rotatebox{90}{Physical}}, fit = (hardware_wrap) (hardware_unwrap)] (1) {};

        % flow of information
        \draw [arrow] (app_wrap) -- (udp_wrap);
        \draw [arrow] (udp_wrap) -- (ip_wrap);
        \draw [arrow] (ip_wrap) -- (ethernet_wrap);
        \draw [arrow] (ethernet_wrap) -- (hardware_wrap);
        \draw [arrow] (hardware_wrap) -- (hardware_unwrap);
        \draw [arrow] (hardware_unwrap) -- (ethernet_unwrap);
        \draw [arrow] (ethernet_unwrap) -- (ip_unwrap);
        \draw [arrow] (ip_unwrap) -- (udp_unwrap);
        \draw [arrow] (udp_unwrap) -- (app_unwrap);
    \end{tikzpicture}


    \caption{A simplified version of the OSI model.
    The Open Systems Interconnection (OSI) model provides a high-level description of the standard
implementation of the network stack.
Shown here are the wrap and unwrap components of each layer. Arrows show flow of data. Session, presentation, and application layers are combined into a single ``higher-level'' layer---these layers are unnecessary for our use case of a simple thermometer.}
    \label{fig:network-stack}
\end{figure}
Key to a networked temperature sensor is the code responsible for networking,
which allow two computers communicate over the internet.
% The standard protocol for network communication is defined in
% a variety of standardized specifications from a standard body of technical
% specifications, such as Request For Comment (RFC) and IEEE documents.
The network stack is divided into logical layers, as seen in figure~\ref{fig:network-stack}, which depicts the Open Systems Interconnection (OSI) model.
Each layer has a plain-language specification
consisting of either a Request For Comment (RFC) or an IEEE document
that describes the standard interface for interacting with that layer.
At a minimum, each layer defines how to
\textit{wrap} and an \textit{unwrap} packets,
though more functionality is needed for other important processes such as
addressing.
As such, we can think of the network stack as a series of composable
encoders and decoders,
where the call to decode a packet of data might look like
\lstinline{udp_unwrap(ip_unwrap(eth_unwrap(hardware_packet)))}.


If everything works perfectly, then after a packet of data is encoded
and sent over the physical transmission medium, decoding it should
result in the same packet of data, unaltered.
One of the principal design features of the OSI model is that since
it is layered, this statement need only apply within a particular layer.
That is, we expect that if we execute the statement
\lstinline{y := udp_wrap(x)}, then the statement
\lstinline{z := udp_unwrap(y)} should
result in the unwrapped packet of data \lstinline{z} being exactly equal to
the initial packet of data \lstinline{x}.
If we treat them as functions, we can say that \lstinline{udp_unwrap} is
the \textit{right inverse} of \lstinline{udp_wrap}.

\subsection{UDP}
\begin{figure}[htb]
    \centering
\begin{lstlisting}[language=file]
                  0      7 8     15 16    23 24    31
                 +--------+--------+--------+--------+
                 |     Source      |   Destination   |
                 |      Port       |      Port       |
                 +--------+--------+--------+--------+
                 |                 |                 |
                 |     Length      |    Checksum     |
                 +--------+--------+--------+--------+
                 |
                 |          data octets ...
                 +---------------- ...

                      User Datagram Header Format
\end{lstlisting}
    \caption{The format of a wrapped UPD packet, taken from RFC 768 (\cite{rfc768})}
    \label{fig:udp-wrap-rfc}
\end{figure}
In this thesis, we primarily consider
the wrap transformation of UDP (a protocol which is responsible for
handling packets sent to or from different applications on the same machine),
which can be seen in the transport layer (second layer) of
figure~\ref{fig:network-stack}.
UDP wrap takes as input data passed from the application layer (top layer in figure~\ref{fig:network-stack}), and outputs data suitable for the network layer.
In our case of a networked fish tank thermometer, UDP wrap will receive the raw temperature data as an input.
The format of results of UDP wrap is shown in figure~\ref{fig:udp-wrap-rfc};
encoding in the UDP layer consists of prepending a header
to the data passed in from the layer above.
This header consists of some routing information, namely a source and
destination port, as well as some additional information about the
data being sent, including length and a checksum.



\section{seL4}
The seL4 microkernel (\cite{Klein2014Verification}) is a verified microkernel
that is performant and secure.
The seL4 microkernel provides two important isolation abstractions:
protection domains (PDs),
which can be loosely described as address spaces that provide isolation from
other processes,
and memory regions, which are blocks of physical memory.
There is a many-to-many relationship between PDs and memory regions.
This allows for a memory region to be shared between two or more PDs,
allowing for transfer of data between the PDs
(see blue box at top of figure~\ref{fig:sel4-mem-pd}),
as well as storage of data within
a single PD
(see cyan and green boxes at bottom of figure~\ref{fig:sel4-mem-pd}).
Additionally, seL4 provides an application programming interface (API) for notifications,
whereby a PD can notify a second PD, and the second can,
on receipt of that notification, execute some command.

\begin{figure}[h]
    \centering
    \scalebox{0.8}{
    \begin{tikzpicture}[node distance=4cm]
        % styles
        \tikzstyle{cell} = [rectangle, minimum width=4.6cm, minimum height=3cm, text centered, draw=black]
        \tikzstyle{arrow} = [line width=2pt,->,>=latex,draw=gray]
        \tikzstyle{box} = [draw, rectangle, align=center, minimum width=11cm, inner sep=3ex]

        % wrap
        \node (mem0) [cell, fill=blue!80] {\LARGE shared memory region};
        \node (PD1) [cell, fill=cyan!80, below left=20pt of mem0] {\LARGE Protection Domain};
        \node (PD2) [cell, fill=green!80, below right=20pt of mem0] {\LARGE Protection Domain};
        \node (mem1) [cell, fill=cyan!80, below=60pt of PD1] {\LARGE memory region};
        \node (mem2) [cell, fill=green!80, below=60pt of PD2] {\LARGE memory region};
        \node [color=red] at (0, -150pt) {blocked access};
        \node [color=green!200] at (-115pt, -180pt) {good access};

        % flow of information
        \draw [arrow, <->] (PD1) -- (PD2) node[midway, above] {notification};
        \draw [arrow, draw=green] (PD1) -- (mem1);
        \draw [arrow, draw=green] (PD2) -- (mem2);
        \draw [arrow, draw=green] (PD1) -- (mem0);
        \draw [arrow, draw=green] (PD2) -- (mem0);
        \draw [arrow, draw=red!40, -{> Square[black]}] (PD1) -- (mem2);
        \draw [arrow, draw=red!40, -{> Square[black]}] (PD2) -- (mem1);
    \end{tikzpicture}}
    \caption{A depiction of some core components of the seL4 microkernel.
    Protection Domains (PDs) can be associated with memory regions,
    and are only able to read or modify those memory regions.
    Additionally, PDs can communicate with each other through notifications.}
    \label{fig:sel4-mem-pd}
\end{figure}

For the purposes of this thesis, we will operate under the assumption that
the UDP layer exists in a completely isolated PD, meaning
we disallow arbitrary changes to state by other processes;
the only state changes that occur should be ones initiated by the UDP
layer itself.
In the broader picture of the project, we plan to experiment with putting
each layer in a separate PD,
with shared memory regions between adjacent layers to facilitate transfer of data.
In this case, the assumption that state will not be changed by outside processes
need only be relaxed within those shared memory regions, where
data can be written or read from either of the adjacent layers at any time.
This case will necessitate some proof that the behaviors of the two layers
do not interfere within this shared region.
Standardizing information flow using a system of queues along with
communicating sequential processes (\cite{csp})
will likely be useful in this case.

\section{Project goals}
The goal of this thesis is to provide proofs and definitions for the UDP layer. Specifically, our goal is to show that, given such conditions, our implementations of the UDP layer will always function correctly.

\chapter{Simplifying assumptions}
\section{State}
While on a high level, wrap and unwrap can be thought of as
functions taking in a packet of data from the layer above, and outputting a
new packet of data suitable for the layer below,
in fact implementing them as pure functions in this manner
is impractically slow when run on hardware.
This slowness stems from the fact that pure functions require that all inputs and outputs be
separate objects.
However, in the case of UDP wrap only the new header need be created,
as all subsequent data will remain the same.

As an alternative, we can model each component of the network stack
as an \textit{imperative program} that changes the \textit{state} of the computer
(the value of each variable or location in memory).
A general definition of a program is shown in figure~\ref{fig:prog-def-det-nondet} as \lstinline{program}.
Here, \lstinline{udp_wrap} (a program) will take as input the current state,
expecting the temperature data from the application layer to be included
within that state in some prescribed way.
Subsequently, \lstinline{udp_wrap} will modify the state so that just before the
temperature data lies the UDP header.
This modified state is the output of \lstinline{udp_wrap}.

\begin{figure}[htb]
    \centering
\begin{lstlisting}[language=isabelle]
type_synonym 'state_space program $=$ "'state_space $\Rightarrow$ 'state_space"
fun udp_wrap :: "network_state_space det_program" where $\cdots$
\end{lstlisting}
    \caption{Example definitions for state-modifying programs.
    A deterministic program is defined for a
    given state space \lstinline{'state_space}
    as a function that takes a state to a new state.
    The program \lstinline{udp_wrap} is then defined, with its type signature
    being a program that operates on the network stack state space.
    The function body of the \lstinline{udp_wrap} is omitted.
    }
    \label{fig:prog-def-det-nondet}
\end{figure}

There are some additional complicating factors that arise when considering
state.
Namely, the microkernel must be able preempt the execution
of a particular program at any time.
Afterwards, the microkernel may either resume execution of the program,
or execute another program.
Consequently, we cannot rely on each command of our program
being run in order without interruptions.
To rectify this, we make several assumptions about how state can be transformed.

Since seL4 is verified, there exist proofs that the microkernel
will behave reasonably---that is, any interruptions to program execution
happen in a well-defined way, and as discussed above, memory access rights
must be explicitly specified.
This means that in seL4, only the PDs with explicit access to
shared memory regions can possibly influence the state of another PD.

While we eventually intend to invoke the seL4 proofs to show that any
transformation of state by other PDs will happen in expected ways
for this thesis we make the assumption that
only the UDP wrap and UDP unwrap programs can influence state,
and will run without interruption.
This is equivalent to assuming that the UDP wrap program runs within
a PD without any shared memory regions, and that the seL4 microkernel itself
will not modify our program's state nor meaningfully interrupt execution.
Additionally, we assume that all memory accesses performed in the execution of
the UDP wrap program will succeed, and not trap or fault.
% TODO: this is clunky

Lastly,
we will not consider the execution of any layer lower than the transport layer,
nor the transmission of data over physical wires.
Rather, we assume that no packets of data will be dropped, corrupted, or received in
a different order than sent.
Our goal is to show that given such conditions,
our implementations of the UDP layer will always function correctly.

\subsection{C compiler and hardware}
As described in RFC 768, the UDP specification precisely describes
the arrangement of bits within a UDP packet.
However, RFC 768 does not make any assumptions about word size on the computer.
In our case, we will divide any packet of data into several 8-bit byte segments
(this choice is implied by the specification, but not explicitly required),
which necessitates some assumptions about hardware.
Fortunately, all modern hardware can accommodate separation of data
into 8-bit bytes.
% TODO: clunky?

As we introduce proofs about our implementation in C of UDP wrap,
we will also have to assume that the C compiler is correct.
There do exist verified C compilers (\cite{compcert}),
and it is also possible to perform proofs on a set of compiled instructions
(done by seL4, see \cite{Klein2014Verification}{4}),
but such considerations are beyond the scope of the current project.
% TODO: mention unspecified C behavior?

Finally, as all of our proofs and definitions are expressed within the Isabelle
assume Isabelle works correctly (it has a proven core).

\chapter{Results}

\section{Overview}
\begin{figure}[h]
    \centering
    \begin{tikzpicture}[node distance=4cm, every node/.style={scale=1.3}]
        % styles
        \tikzstyle{cell} = [rectangle, minimum width=4.6cm, minimum height=3cm, text centered, draw=black]
        \tikzstyle{arrow} = [line width=2pt,->,>=latex,draw=gray]
        \tikzstyle{box} = [draw, rectangle, align=center, minimum width=11cm, inner sep=3ex]

        % wrap
        \node (abstract) [cell, fill=cyan!80] {\LARGE abstract specification};
        \node (invs) [cell, fill=orange!80, right=120pt of abstract] {\LARGE invariants};
        \node (design) [cell, fill=green!80, below=140pt of abstract] {\LARGE design specification};

        % \node [color=red] at (0, -150pt) {blocked access};
        % \node [color=green!200] at (-115pt, -180pt) {good access};

        % flow of information
        \draw [arrow] (design) -- (abstract) node[midway, left] {\rotatebox{90}{refines}};
        \draw [arrow] (invs) -- (abstract) node[midway, above] {always true for};
    \end{tikzpicture}
    \caption{Depiction of the proof architecture explored in this thesis.
    A high-level description of what \lstinline{udp_wrap} should do
    is described in code in the abstract specification.
    A more concrete implementation which makes some assumptions about hardware
    is then defined in the design specification.
    Desirable qualities of \lstinline{udp_wrap} are described as invariants,
    which apply to the abstract specification.
    Lastly, a notion of program correspondence is shown between the
    abstract and design specification---namely, the design specification
    should refine the abstract specification.
    }
    \label{fig:proof-structure-abstract-design}
\end{figure}
The proof architecture we present in this thesis is structured into
two overarching divisions: specifications and proofs.
Specifications precisely define how a software works.
In our case, we have two specifications for UDP wrap.
First we have an abstract specification,
which defines the process of prepending a header to a packet of data
in precise terms, but ignoring many implementation details that would
be important for execution on actual hardware.
Next, we have a design specification,
which describes the same behavior, but using the language of bits and bytes
that is more amenable to hardware.

The two types of proofs we have are invariants and refinement.
An invariant is a property of the abstract specification that should always
be true. These are used to show that our specification does what we want it to
do. In our case, the statement that UDP unwrap should be the inverse of UDP wrap
is an invariant,
since it should always be true regardless of what data is being sent.
Refinement is the process of showing that the design specification
corresponds to the abstract specification.
Specifically, refinement states that every possible result of the design
specification is an allowed result of the abstract specification.
Since we know from the invariant that the abstract specification
works the way we want it to, through refinement we know
that the design specification also works the way we want it to.


\section{Abstract specification}
In the abstract specification, we model all fields as natural numbers,
disregarding size.
As such, we transition from thinking about packets of data
(the phrasing of which invites thinking of hardware)
to a more abstract notion of a message,
namely a list of natural numbers (see line 1 of \ref{fig:defs-abstract}).

\begin{figure}[htpb]
    \centering
\begin{nlisting}[language=isabelle]
type_synonym message $=$ "nat list"
type_synonym ip_addr $=$ "nat"
type_synonym port $=$ "nat"
type_synonym socket $=$ "ip_addr $\times$ port"
type_synonym connection $=$ "socket $\times$ socket"
definition src :: "connection $\Rightarrow$ socket" where "src c $=$ fst(c)"
definition dst :: "connection $\Rightarrow$ socket" where "dst c $=$ snd(c)"
\end{nlisting}
    \caption{Basic definitions for our UDP abstract specification.
        Fundamental types in the network stack are defined,
        including messages and connections.
        Additionally, helper functions are provided to facilitate
        the extraction of source and destination sockets from a connection.}
    \label{fig:defs-abstract}
\end{figure}

Additionally, we define the routing information used throughout the
network stack.
Network communication is done over a connection,
which is uniquely defined by a source and destination socket
(see lines 5,6, and 7 in figure~\ref{fig:defs-abstract}).
A socket consists of an IP address and a port number (line 4 of figure~\ref{fig:defs-abstract}), both of which are again natural numbers.
Note that here, we assume
that UPD will be used in conjunction with IP,
hence the inclusion of an IP address.


We define the abstract UDP wrap using the pure function approach:
UDP wrap should take in a message from the application layer above,
then use information about the connection to create a header.
Finally, UDP wrap will output a new message, which consists of the header
prepended to the old message, to be sent to the IP layer below.
The precise definition is shown in figure~\ref{fig:wrap-abstract}.

\begin{figure}[htpb]
    \centering
\begin{lstlisting}[language=isabelle]
definition udp_wrap :: "message $\Rightarrow$ connection $\Rightarrow$ message" where
  "udp_wrap msg conn $\equiv$ (let
                          src_sk $=$ src conn;
                          dst_sk $=$ dst conn;
                          src_ip_addr $=$ ip_addr src_sk;
                          dst_ip_addr $=$ ip_addr dst_sk;
                          src_port $=$ port src_sk;
                          dst_port $=$ port dst_sk;
                          len $=$ length_octets msg $+$ udp_hdr_sz
                        in
                          [src_port, dst_port, len,
                           checksum16 [src_ip_addr,
                                       dst_ip_addr,
                                       0, udp_proto, len]
                          ]) $@$ msg"
\end{lstlisting}
    \caption{The definition of UDP wrap in the abstract specification.
        The notation used here serves to say that \lstinline{udp_wrap}
        is a nonrecursive function that takes two arguments:
        a message \lstinline{msg}, and a connection \lstinline{conn},
        and outputs a new message.
        The function creates the header from the connection information,
        and then returns
        the header, presented as a list of computed natural numbers,
        appended via the $@$ operator with the input message
        \lstinline{msg}.
    }
    \label{fig:wrap-abstract}
\end{figure}

Some features of this implementation of the specification bear mentioning.
First, as specified by RFC 768, the length field (depicted in figure~\ref{fig:udp-wrap-rfc}) should be the total size of the output message in octets.
This is not necessarily the length of the message itself,
since the message is expressed as a list of natural numbers, rather than
a list of octets.
This is represented in the definition on line 9 of figure~\ref{fig:udp-wrap-rfc}.



\section{Design specification}

\begin{figure}[htpb]
    \centering
\begin{lstlisting}[language=isabelle]
type_synonym message_d = "byte list"
(* IPv6 addresses consist of 8 16-bit words *)
type_synonym ip_addr_d $=$ "word16 $\times$ word16 $\times \cdots \times$ word16"
type_synonym port_d $=$ "word16"
type_synonym socket_d $=$ "ip_addr_d $\times$ port_d"
type_synonym connection_d $=$ "socket_d $\times$ socket_d"
\end{lstlisting}
    \caption{Basic definitions for our UDP design specification.
    Fundamental types in the network stack are defined
    in terms of bytes and 16-bit words.
    Omitted here for the sake of brevity are most of the 16-bit words
    that make up an IPv6 address---in the true Isabelle specification,
    all 8 16-bit words are listed.}
    \label{fig:defs-design}
\end{figure}

The design specification proceeds very similarly to the abstract specification,
but with all fields defined in terms of bytes or 16-bit words rather than
natural numbers, as seen in figure~\ref{fig:defs-design}.
Words are defined here using the Isabelle Word library
(\cite{Word_Lib-AFP}).

Worthy to note here is that many fields are too large to fit into
a single atom of the message.
For instance, the message consists of a list of
8-bit bytes, while a port consists of a 16-bits.
This means that some additional helper functions are needed
to split up ports into byte-sized pieces.
The function for ports is displayed in figure~\ref{fig:porttomsg-design}.

\begin{figure}[htpb]
    \centering
\begin{lstlisting}[language=isabelle]
definition porttomsgd :: "port_d $\Rightarrow$ message_d" where
  "porttomsgd p $=$ [w16tow8h p, w16tow8l p]"
\end{lstlisting}
    \caption{Function to convert a 16-bit port to a message
        consisting of 8-bit words.
        This conversion is done by listing first the 8
        most-significant bits of the port, followed by
        the remaining 8 less-significant bits.}
    \label{fig:porttomsg-design}
\end{figure}

\begin{figure}[htpb]
    \centering
\begin{nlisting}[language=isabelle]
definition udp_wrap_d :: "message_d $\Rightarrow$ connection_d $\Rightarrow$ message_d"
where "udp_wrap_d msg conn $\equiv$ (let
                            src_sk $=$ src conn;
                            dst_sk $=$ dst conn;
                            src_ip_addr $=$ ip_addr src_sk;
                            dst_ip_addr $=$ ip_addr dst_sk;
                            src_port $=$ port src_sk;
                            dst_port $=$ port dst_sk;
                            len $=$ (of_nat
                        (length msg $+$ udp_hdr_sz)::word16);
                            chksum $=$ (0 :: word16)
                          in
                            (porttomsgd src_port $@$
                             porttomsgd dst_port $@$
                             w16tomsg len $@$
                             w16tomsg chksum
                            ) $@$ msg)"
\end{nlisting}
    \caption{The definition of UDP wrap in the design specification.
        Again, we construct the header from the connection information,
        then return the header appended with the input message.
    }
    \label{fig:wrap-design}
\end{figure}

The definition for UDP wrap in the design specification is
again very similar to the definition in the abstract specification.
One of the more notable differences is
that rather than expressing the header as a list of natural numbers,
we must instead express it as result of several list appends,
as seen in lines 13 through 17 of figure~\ref{fig:wrap-design}.
Additionally, since here we have already formatted the message as
a list of bytes, we can simply take the length of the message
to compute the length field.






\section{Invariants}

\begin{figure}[htpb]
    \centering
\begin{lstlisting}[language=isabelle]
lemma "
&\color{green!200}{\{precondition\}}&
&\color{cyan!200}{program that changes state}&
&\color{blue!180}{\{postcondition\}}&
    "
\end{lstlisting}

    \caption{Structure of a Hoare Triple.
        This statement is read as
        ``assuming {\color{green!200}precondition} is true,
        and {\color{cyan!200}program that changes state} is a terminating
        program, then {\color{blue!180}postcondition} is true.
        }
    \label{fig:hoare-triple-structure}
\end{figure}

We present all invariants as Hoare triples (\cite{hoare-triple}), which is a
statement on a state-transforming imperative program.
Hoare triples are of the form shown in figure~\ref{fig:hoare-triple-structure},
and consist of a precondition, a terminating program, and a postcondition.
In this context, a program is defined as in figure~\ref{fig:prog-def-det-nondet},
and takes as input an initial state, executes some computations, then returns
an output state.
Additionally, the precondition operates on the initial state, while the
postcondition operates on the final state.
For this thesis, all Hoare triples are formulated using the HOL-Hoare
library in Isabelle (\cite{hol-hoare-lib}).


In this thesis, we have focused on defining the UDP wrap functionality,
and have not discussed UDP unwrap at length.
Hence, we will provide the statement of an invariant
that UDP unwrap is the inverse of UDP wrap, but not prove it.
This statement is presented in figure~\ref{fig:inv-unwrap-wrap}.


\begin{figure}[htpb]
    \centering
\begin{lstlisting}[language=isabelle]
lemma compose_to_id:
"VARS orig_msg wrapped_msg unwrapped_msg conn
&\color{green!200}{\{well\_formed orig\_msg conn\}}&
&\color{cyan!200}{wrapped\_msg := udp\_wrap orig\_msg conn;}&
&\color{cyan!200}{unwrapped\_msg := udp\_unwrap wrapped\_msg}&
&\color{blue!180}{\{orig\_msg = unwrapped\_msg\}}&"
\end{lstlisting}
    \caption{Invariant stating that UDP unwrap is the inverse of UDP wrap.}
    \label{fig:inv-unwrap-wrap}
\end{figure}

The \lstinline{compose_to_id} invariant states that, given the original message
and connection are well-formed (that is, the port is an allowed port, etc.),
then after you wrap and unwrap the message, the result should
be identical to the starting message.

One of the advantages of Hoare triples is that they can be composed.
Hence, if we had a similar Hoare triple stating that for the IP layer,
taking an arbitrary well-formed message and connection,
wrapping the message and subsequently unwrapping it results in the original
message (which is exactly what we have in figure~\ref{fig:inv-unwrap-wrap},
but for the IP layer), then we can insert the IP wrap and unwrap
statements in between the UDP wrap and unwrap statements while
still preserving the outer pre- and post-conditions.
In this manner, we hope that proofs for a single layer can combine
to obtain greater proofs about the network stack as a whole.

\begin{figure}
    \centering
\begin{lstlisting}[language=isabelle]
lemma larger_after_wrap: "VARS buf_up buf_down conn
&\color{green!200}{\{True\}}&
&\color{cyan!200}{buf\_down := udp\_wrap buf\_up conn}&
&\color{blue!180}{\{length buf\_down > length buf\_up\}}&
"
  apply (vcg)
  by (simp)
\end{lstlisting}
    \caption{Invariant saying that UDP wrap will always increase the size
        of a message.}
    \label{fig:inv-wrap-inc}
\end{figure}

An example of a more easily provable invariant can be seen in figure~\ref{fig:inv-wrap-inc}. This invariant has a trivial precondition,
and shows that after execution of UDP wrap, the resulting
message should have grown in length.
While perhaps a less obviously useful invariant,
it provides a sanity check that the UDP wrap function
has added a nonempty header.
This invariant can be composed in exactly the same way with other
invariants, for example to show that the result of a UDP wrap followed
by an IP wrap will also increase the length of the message.

In general, we expect the role of invariants to be complementary to the
abstract specification---the abstract specification is the definitive
definition of how our program should behave.
The purpose of an invariant is to say that that behavior is interesting
or meaningful, not specify exactly what the behavior is.


\section{Refinement}

The largest part of our proofs is refinement, where we show that
the design specification is a valid implementation of the abstract specification.
Continuing from the description of refinement above,
when we say that the design specification of UDP wrap refines the
abstract specification of UDP, we mean that
every possible result of the design version of UDP wrap is an allowed
result of the abstract specification version.

The abstract and design specifications have now been defined, meaning the
only remaining definition needed to create a statement of refinement is
what it means for a result in the design specification to be ``allowed''
by a result in the abstract specification.
This entails determining a relationship between messages and connections
in the design specification and messages and connections in the abstract setting.

\begin{figure}[h]
    \centering
\begin{nlisting}
inductive relation_message' :: "message $\Rightarrow$ message $\Rightarrow$ bool" where
same:         "relation_message' ms ms" |
split:        "(relation_message' ms1 ms1' $\land$
                relation_message' ms2 ms2') $\Longrightarrow$
               relation_message' (ms1 $@$ ms2) (ms1' $@$ ms2')" |
step_combine: "((m2' $<$ 2^8) $\land$
                (m = m1' $*$ 2^8 $+$ m2) $\land$
                (relation_message' ms ms')) $\Longrightarrow$
               (relation_message' (m $\#$ ms) (m1' $\#$ m2' $\#$ ms'))"
definition relation_message :: "message $\Rightarrow$ message_d $\Rightarrow$ bool" where
  "relation_message ms ms' = (relation_message' ms (map unat ms'))"

lemma "relation_message [260] [1,4]"
  by (simp add: same step_combine relation_message_def)
\end{nlisting}
    \caption{Relation between an abstract and a design message.
    \lstinline{relation_message'} is property on a pair of abstract
    messages that encapsulate the fact that two abstract messages could
    correspond to the same data, due to there being no limit as to how large a natural number can be.
    Lastly, an example proof for a relation between an abstract and a design message is shown.
    }
    \label{fig:rel-msg}
\end{figure}

The relation between abstract and design messages is the harder of the two to define,
owing to the fact that abstract messages are lists of arbitrary-size natural numbers, while
design messages are lists of 8-bit words where no value can exceed
$2^8-1 = 255$.
As discussed previously, this means that several fields, such as the port numbers in the header,
will be divided into several items in the design message, but remain as one item in the abstract
message.
The goal of the \lstinline{relation_message'} property defined in lines 1 through 9 of
figure~\ref{fig:rel-msg} is to clarify exactly when two abstract messages contain the same
information.
For instance, consider the abstract messages $[260]$ and $[1, 4]$.
Since $260 = 1 \cdot 256 + 4$, both messages can represent the same information,
and likewise it is possible to prove that they are related under \lstinline{relation_message'}.
Such a proof is provided in lines 13 and 14 in figure~\ref{fig:rel-msg}.

\begin{figure}[h]
    \centering
    \begin{lstlisting}[language=isabelle]
fun ip_addr_d_to_nat :: "ip_addr_d $\Rightarrow$ nat" where
  "ip_addr_d_to_nat (a,b,c,d,e,f,g,h) = (unat a)*2^(16*7) +
                                        (unat b)*2^(16*6) +
                                        $\vdots$
                                        (unat h)*2^(16*0)"
definition relation_socket :: "socket $\Rightarrow$ socket_d $\Rightarrow$ bool"
  where "relation_socket sock sock_d $\equiv$ (
    (ip_addr_a sock = ip_addr_d_to_nat (ip_addr_d sock_d)) $\land$
    (port_a sock = unat (port_d sock_d))
        )"
definition relation_connection :: "connection $\Rightarrow$ connection_d
                                   $\Rightarrow$ bool"
  where "relation_connection con con_d $\equiv$ (
              relation_socket (src_a con) (src_d con_d) $\land$
              relation_socket (dst_a con) (dst_d con_d)
        )"
    \end{lstlisting}
    \caption{Relation between an abstract and a design connection.
    This relation relies on several smaller conversions from 8 and 16-bit words to natural numbers.
    }
    \label{fig:rel-conn}
\end{figure}

The relation between abstract and design connections is more easily followed than that of messages.
A connection is a pair of sockets, and a socket is an IP address and a port number.
Thus, the natural relation is that all constituent abstract IP addresses and port numbers in a connection
are related to their concrete counterparts.
For port numbers, we can directly convert from 16-bit word port numbers in the design specification
to natural numbers in the abstract specification.
For IP addresses, it is slightly more complicated, since in the design specification,
an IP address is represented as a sequence of 8 16-bit words, rather than one 128-bit word.
As such, we offset each word in the sequence by 8 bits by multiplying by powers of $2^{16}$,
which results in a single natural number which can be directly compared to the abstract specification.

\begin{figure}[ht]
    \centering
\begin{lstlisting}[language=isabelle]
theorem refinement:
  assumes "length msg $=$ length msg_d" and
          "relation_message msg msg_d" and
          "relation_connection conn conn_d"
  shows "relation_message (udp_wrap msg conn) (udp_wrap_d msg_d conn_d)"
  apply simp
  proof -
  have "relation_socket (Network_A.src conn) (Network_D.src conn_d)"
    using assms relation_connection_def
    by (simp)
  $\vdots$
  thus "relation_message
     (Network_A.port (Network_A.src conn) #
      Network_A.port (Network_A.dst conn) #
      (length msg + Udp_A.udp_hdr_sz) #
      0 #
      msg)
     (porttomsgd (Network_D.port (Network_D.src conn_d)) @
      porttomsgd (Network_D.port (Network_D.dst conn_d)) @
      w16tomsg (word_of_nat (length msg_d) +
                word_of_nat Network_Consts.udp_hdr_sz) @
      w16tomsg 0 @
      msg_d)"
    using 1 relation_message_def split
    by fastforce
\end{lstlisting}
    \caption{Formal statement of refinement. Proof partially omitted due to length.
    The format of the proof uses the Isar-style of describing the assumptions and
    goal of a theorem.
    Here, we show that if the abstract and design messages are the same length and are related,
    and the design and abstract connections are related, then
    the result of the abstract and design versions of UDP wrap should also be related.
    }
    \label{fig:refine}
\end{figure}

Combining both the relation between abstract and design messages,
and the relation between abstract and design connections,
we are able to formulate the statement of refinement for UDP wrap.
The statement, along with a truncated proof, is shown in figure~\ref{fig:refine}.
While truncated in the figure, the proof is complete, albeit relying on some
properties of conversion between 8-bit words, 16-bit words, and natural numbers.
Hence, we have shown that the design specification refines the abstract specification for
UDP wrap.


\subsection{Ongoing work: integrating C code}

\begin{figure}[h]
    \centering
\begin{lstlisting}
external_file "file.c"
install_C_file "file.c"
context playground_global_addresses
begin

thm function_def

end
\end{lstlisting}
    \caption{Example conversion of C code to SIMPL}
    \label{fig:convert-c}
\end{figure}

We have shown refinement, however we have shown refinement between two
specifications defined solely in Isabelle;
while the design specification is more similar to what would run on hardware,
it is still not production-ready code.
Hence, the next step in the proof of the UDP layer ought to involve
an efficient implementation written in C.
We will then show that the C implementation refines the design specification.
While we have not yet begun to show refinement for this case,
we have experimented with converting C code into SIMPL, an imperative
language defined in Isabelle.
The conversion process (seen in figure~\ref{fig:convert-c}) was created for use
in seL4, and is formally verified.

    \begin{figure}
        \centering
        \scalebox{0.6}{
        \begin{tikzpicture}[node distance=4cm]
            % styles
            \tikzstyle{cell} = [rectangle, minimum width=4.6cm, minimum height=3cm, text centered, draw=black]
            \tikzstyle{arrow} = [line width=2pt,->,>=latex,draw=gray]
            \tikzstyle{box} = [draw, rectangle, align=center, minimum width=11cm, inner sep=3ex]

            % wrap
            \node (abstract) [cell, fill=cyan!80] {\LARGE abstract specification};
            \node (invs) [cell, fill=orange!80, right=120pt of abstract] {\LARGE invariants};
            \node (design) [cell, fill=green!80, below=60pt of abstract] {\LARGE design specification};
            \node (cspec) [cell, fill=lavender!80, below=60pt of design] {\LARGE C specification};
            \node (ccode) [cell, fill=lavender!80, right=120pt of cspec] {\LARGE C code};

            % \node [color=red] at (0, -150pt) {blocked access};
            % \node [color=green!200] at (-115pt, -180pt) {good access};

            % flow of information
            \draw [arrow] (abstract) -- (design) node[midway, left] {\rotatebox{90}{refines}};
            \draw [arrow] (design) -- (cspec) node[midway, left] {\rotatebox{90}{refines}};
            \draw [arrow] (invs) -- (abstract) node[midway, above] {always true for};
            \draw [arrow] (ccode) -- (cspec) node[midway, above] {translates to};
        \end{tikzpicture}}
        \caption{Updated proof architecture, including C code and a C specification.}
        \label{fig:proof-structure-c}
    \end{figure}

Through this process, we will modify the proof architecture to follow figure~\ref{fig:proof-structure-c}.
The C code is converted into a C specification, expressed in Isabelle as a SIMPL program.
This conversion exactly preserves all behaviors of the C code.
Next, we show that the C specification refines the design specification.
Since refinement is transitive, this means the C specification refines the abstract specification,
and is thus a correct implementation of UDP wrap.

\chapter{Conclusions}
In this thesis, we have begun the process of formal verification of UDP wrap.
We have done this in four steps.
First, we created an abstract specification which precisely defines
how we expect UDP wrap to work.
Next, we created a design specification of UDP wrap which operates more alike to hardware.
Third, we showed that various desirable invariants are satisfied by the abstract specification.
Finally, we showed that the design specification is a refinement of the abstract specification.
Additionally, we discussed possibilities for how integration of C code might work in the
context of these proofs.

It bears mentioning that the abstract specification is unwieldy
compared to the design specification
when it comes to IP addresses---Isabelle represents natural numbers using standard
Peano axioms,
which require increased computational power proportional to the magnitude of the number.
As such, numbers on the order of $2^{128}$ are too large for most if not all computers.
Numbers on the order of only $2^{16}$, however, are manageable even when simultaneously
using eight of them.
Consequently, it is not feasible to convert the design IP address
$(1,2,3,4,5,6,7,8)$ to a single natural number as we expect abstract IP addresses
to be.
This poses no issues for the UDP layer, which need not manipulate IP addresses,
but could pose problems when extending to the IP layer.

The approach used here of specifications, invariants, and refinement
has been successful for our scope of verification of UDP wrap.
While this approach is already familiar, having been used extensively in the proof of seL4,
it is promising that it seems to apply to our use case of a networked temperature sensor as well.
We hope to extend our refinement to the level of C code, and further expand to other parts of the
network stack in future work.

\chapter{Future work}
As stated, the likely next step for the eventual verification of a networked temperate sensor
is to verify that C code refines an abstract specification.
As earlier, this presents several additional challenges, and will
likely require a number of new assumptions, including assumptions about
hardware correctness, correctness of the C compiler, and assumptions about the functions of seL4.

Several particularly difficult but fruitful possibilities lie in a close examination of
seL4's PDs.
PDs provide a very strong level of security and isolation, which may prove necessary for proofs.
However, they do so at a costly overhead, as seL4 must manage all PDs carefully.
One question we look to answer in coming research is whether it is necessary
for full formal verification for all layers of the network stack to exist in separate PDs,
or if they can be combined into a single large PD, thus achieving better performance.

Additionally, we will likely encounter new challenges when attempting to verify
other layers of the network stack beyond the UDP layer.
For instance, as discussed above, large IP address numbers are unlikely to be usable
in the earlier definition of the abstract specification.
However, certain IP addresses are reserved, and have special meanings or use as defined in
the corresponding RFC documents.
This could cause issues where the abstract specification must define a particular constant
IP address, but this definition requires an impossibly large number of resources be allotted to
Isabelle.

Lastly, another important avenue of discussion is that the UDP layer does not make many assertions about integrity or confidentiality.
For instance, when using UDP, no guarantee is provided that packets sent in a particular order
will be received in that order.
Unlike UDP, TCP (an alternate protocol for the transport layer) does provide many such guarantees,
and is correspondingly more complex. We anticipate that any verification of TCP will require
a careful treatment of state, and in addition will likely require the use of linear temporal logic
to make statements such as ``a message sent will always eventually be received.''





% If you want to include appendices, just use the \appendix command and then make chapters as normal
\appendix
\chapter{Appendix}
\section{Isabelle session management}
When using Isabelle, it is frequently necessary to invoke several libraries and theories,
some of which may in turn depend on each other.
The correct way to manage complex dependencies in Isabelle is with the session management system.

At the root of your directory tree, a ``ROOTS'' file may be placed, which describes all directories with required sessions (see figure~\ref{fig:isabelle-roots-file}).
Each directory referred to in the ROOTS file must contain a ``ROOT'' file, which provides Isabelle with the information for creating various sessions
(see figure~\ref{fig:isabelle-root-file-spec}).
Sessions in a particular ROOT file may refer to sessions in another, but with some restrictions.
In our example, the refinement session RefineAD deals with the abstract and design specifications, whose theories are contained in sessions
ASpec and DSpec.
Hence, our ROOTS file must contain a reference to both parent directories spec/ (which contains the files for both ASpec and DSpec), and proof/
(which contains the files for ADRefine).
Furthermore, the ADRefine session must explicitly list ASpec and DSpec as required parent sessions in its own ROOT file under proof/ (see figure~\ref{fig:isabelle-root-file-proof}).

\begin{figure}[htpb]
    \centering
    \begin{lstlisting}[style=tree, language=file]
    .
    ├── README.md
    ├── ROOTS
    ├── proof
    │   ├── InvsA
    │   │   └── UDPInverse.thy
    │   ├── ROOT
    │   └── RefineAD
    │       ├── Corres.thy
    │       └── RelationUdp.thy
    └── spec
        ├── Aspec
        │   ├── Network_A.thy
        │   └── Udp_A.thy
        ├── Dspec
        │   ├── Network_Consts.thy
        │   ├── Network_D.thy
        │   ├── Udp_D.thy
        │   └── Word_Network.thy
        └── ROOT
    \end{lstlisting}

    \caption{Example directory structure}
    \label{fig:isabelle-roots-file}
\end{figure}

\begin{figure}[htpb]
    \centering
    \begin{lstlisting}[language=isabelle]
session ASpec in "Aspec" = HOL +
  theories
    "Network_A"
    "Udp_A"

session DSpec in "Dspec" = HOL +
  sessions
    "HOL-Library"
  theories
    "Network_D"
    "Udp_D"
    \end{lstlisting}

    \caption{Example ROOT file in the spec/ directory. Two sessions are created: ASpec (an abstract specification) and DSpec (a design specification).}
    \label{fig:isabelle-root-file-spec}
\end{figure}

\begin{figure}[htpb]
    \centering
    \begin{lstlisting}[language=isabelle]
session RefineAD in "RefineAD" = HOL +
  sessions
    "ASpec"
    "DSpec"
  theories
    "Relation"
    \end{lstlisting}

    \caption{Example ROOT file in the proof/ directory. Note that the RefineAD session relies on the ASpec and DSpec sessions defined in a different ROOT file (in our case, located in the spec/ directory).}
    \label{fig:isabelle-root-file-proof}
\end{figure}

% For the bibliography style, I load `sp.bst', the style used by the LSA in the journal `Semantics and Pragmatics'. For how to include in-line citations with page numbers and other conventions, refer to nus-el-ht.sty.
\backmatter
\bibliography{el-ht.bib}
\end{document}


